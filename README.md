Simple ERC721 

ERC721 is a standard for representing ownership of non-fungible tokens where each token is unique such as in air tickets or real estates. Here, we will create it and deploy it to a public ethereum testnet called Ropsten. We will leverage on an open and well tested libraries called openZeppelin(set of well tested contracts) to create our ERC721 and deploy using the Remix IDE tool.

•	OpenZeppelin- A library for secure smart contract development. Build on a solid foundation of community-vetted code.

•	Remix IDE -  A powerful open source tool that helps you write Solidity contracts straight from the browser.

Setting up the Environment

Open https://remix.ethereum.org/  in your browser preferably google chrome.
If you haven’t used Remix before, you need to setup plugins so that you can use the Solidity Compiler and Deploy and Run Transactions.
 
Importing the contract
   
We will import OpenZeppelin Contracts v3.4.0. (see Importing from GitHub 25 in the Remix documentation).
Note: When importing via GitHub, you should specify the release tag, otherwise you will get the latest code in the master branch. For OpenZeppelin Contracts you should only use code published in an official release.
The ERC721 contract
Create a new Solidity file and name it SimpleERC721.sol
First you need to add pragma solidity ^0.6.0; this tells solidity to use a compiler version of above 0.6.0 but below 0.7.0

 Import the following openZeppelin contracts directly from its github location

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/access/AccessControl.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/GSN/Context.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/Counters.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC721/ERC721.sol";

Then just add the following contract codes


##

contract simpleErc721 is Context, AccessControl, ERC721{

using Counters for Counters.Counter;

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    Counters.Counter private _tokenIdTracker;
    
    mapping (uint256 => uint256) private _tokenData;

    constructor() public ERC721("My SimpleErc721", "Simple721") {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());

        _setupRole(MINTER_ROLE, _msgSender());

        _setBaseURI("https://example.com/api/token/");
    }

    function mint(address to, uint256 tokenData) public virtual {
        require(hasRole(MINTER_ROLE, _msgSender()), "My SimpleErc721: must have minter role to mint");

        _mint(to, _tokenIdTracker.current());
        _tokenData[_tokenIdTracker.current()] = tokenData;
        _tokenIdTracker.increment();
    }

    function tokenData(uint256 tokenId) public view returns (uint256) {
        require(_exists(tokenId), "MyNFT: URI query for nonexistent token");

        return _tokenData[tokenId];
    }
}
##

Our simple ERC721 contract inherits methods from the well tested ERC721.sol of OpenZeppelin.
The contract also uses {AccessControl} to lock permissioned functions using the
 different roles - head to its documentation for details.

- A minter role that allows for token minting (creation)
  - token ID and URI autogeneration

The account that deploys the contract will be granted the minter
  role, as well as the default admin role, which will let it grant minter
  roles to other accounts.

At the constructor, we created a new token for `to`. Its token ID will be automatically
      assigned (and available on the emitted {IERC721-Transfer} event), and the token
   URI autogenerated based on the base URI passed at construction which is https://example.com/api/token/. You can change that to something more suitable.

The contract contains a mint function and a tokenData that allows us to mint and return the tokenData accordingly.

Compiling

Click on the compiler tab on Remix to compile the smart contract.

Deploying.

Make sure you have faucet Ropsten ether in your Metamask wallet. Click on the deployment tab and Deploy the simple ERC721 contract.


Mapping to Polygon Pos Bridge.

we shall be using the proof of stake bridge and metamask to be able to move assets from our root chain(ethereum) to our child chain(matic)

Bridging via Pos using Metamask


You can configure the Matic Mumbai Testnet URL on your Metamask.
Please add the following settings to your network selection of custom RPC

Network Name – Mumbai Testnet

New RPC URL  - https://rpc-mumbai.matic.today

ChainID  - 80001

Symbol  - MATIC

Block Explorer URL – https://mumbai-explorer.matic.today

You need to also submit a mapping request to https://mapper.matic.today/ to be able to transfer assets such as the SimpleERC721 we created to and fro the ethereum and matic network


Deposit ERC721 -

Approve ERC721Predicate contract to spend the tokens that have to be deposited.

Make depositFor call on RootChainManager.
Withdraw ERC721 -

Burn tokens on matic chain.

Call exit function on RootChainManager to submit proof of burn transaction. This call can be made after checkpoint is submitted for the block containing burn transaction.


Once the checkpoint is submitted to the mainchain ERC20 contract, an NFT Exit (ERC721) token is created of equivalent value. Users need to wait for a 7 day challenge period (For testnets wait for ~5 minutes for)
Once the challenge period is complete, the withdrawn funds can be claimed back to your ERC20 acccount from the mainchain contract using a process-exit procedure.


Contributing

This contract is open to contribution.
